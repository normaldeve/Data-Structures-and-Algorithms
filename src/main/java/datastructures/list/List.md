# List 정리

## 배열 (Array) 개요

배열은 가장 기본적인 자료구조로, 인덱스를 사용할 때 가장 효율적입니다. 하지만 다음과 같은 단점을 가지고 있습니다:

- **크기 고정:** 배열은 생성 시 크기를 미리 정해야 합니다.
- **비효율성:**
    - 배열 크기를 너무 크게 잡으면 메모리가 낭비됩니다.
    - 배열 크기를 너무 작게 잡으면 데이터를 저장할 공간이 부족합니다.

## 리스트 (List) 개요

배열의 단점을 보완하기 위해 **동적 크기 조정**이 가능한 리스트 자료구조가 사용됩니다.
Java에서는 리스트 자료구조를 JCF(Java Collections Framework)의 `List` 인터페이스를 통해 제공합니다.

### 특징
- 순서가 있는 컬렉션입니다.
- 중복 저장을 허용합니다.
- `List` 인터페이스의 대표적인 구현체:
    - `ArrayList`
    - `LinkedList`

### ArrayList vs LinkedList

| 특성                           | ArrayList                                      | LinkedList                             |
|--------------------------------|-----------------------------------------------|----------------------------------------|
| **구조**                       | 배열 기반                                     | 이중 연결 리스트 기반                      |
| **추가/삭제 위치 탐색**         | `O(1)` (인덱스 기반)                         | `O(n)` (노드 탐색 필요)                   |
| **데이터 추가/삭제**            | `O(n)` (데이터 밀기 필요)                    | `O(1)` (참조 변경으로 처리)               |
| **중간 삽입 효율성**            | 이론적으로 느릴 수 있지만, 메모리 고속 복사로 단점 완화 | 이론적으로 빠를 수 있음                    |

**권장사항:** 대부분의 경우 `ArrayList`를 기본으로 사용하세요.

---

## List 인터페이스 주요 메서드

| 메서드                                 | 설명                                    |
|---------------------------------------|---------------------------------------|
| `add(E e)`                            | 리스트 끝에 지정된 요소 추가                    |
| `add(int index, E element)`           | 리스트의 지정된 위치에 요소 추가                |
| `addAll(Collection<? extends E> c)`   | 지정된 컬렉션의 모든 요소를 리스트 끝에 추가        |
| `get(int index)`                      | 리스트에서 지정된 위치의 요소를 반환             |
| `set(int index, E element)`           | 지정된 위치의 요소를 지정된 요소로 변경           |
| `remove(int index)`                   | 지정된 위치의 요소를 제거하고 반환               |
| `clear()`                             | 리스트의 모든 요소를 제거                      |
| `indexOf(Object o)`                   | 리스트에서 지정된 요소의 첫 번째 인덱스를 반환       |
| `lastIndexOf(Object o)`               | 리스트에서 지정된 요소의 마지막 인덱스를 반환       |
| `contains(Object o)`                  | 지정된 요소를 포함하고 있는지 여부 반환           |
| `sort(Comparator<? super E> c)`       | 리스트 요소를 지정된 비교자에 따라 정렬            |
| `size()`                              | 리스트 요소 개수를 반환                       |
| `isEmpty()`                           | 리스트가 비어 있는지 여부 반환                   |
| `toArray()`                           | 리스트의 모든 요소를 배열로 반환                 |

---

`List` 인터페이스와 구현체를 활용하면 배열의 고정 크기 문제를 해결하고, 동적 크기와 순서가 있는 데이터를 효율적으로 관리할 수 있습니다.

<img width="312" alt="스크린샷 2025-01-19 오전 12 03 27" src="https://github.com/user-attachments/assets/d4e15b9c-2977-4056-9586-722ca4b30533" />
<img width="328" alt="스크린샷 2025-01-19 오전 12 03 51" src="https://github.com/user-attachments/assets/acfe9d82-2298-4863-9c2c-4cdf17ac10d1" />

실제로 내가 구현한 ArrayList와 JCF에서 구현한 ArrayList의 성능 차이를 두 눈으로 확인해보니 얼마나 최적화가 잘되어 있는지 알 수 있었습니다.
데이터를 맨 앞에서 계속해서 추가하는 작업을 제외한다면 ArrayList를 사용하는 것이 좋을 거 같습니다

